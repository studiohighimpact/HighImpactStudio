<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

    <title>High Impact Studio | Software & IA</title>
    <meta name="description" content="Impulsa tu negocio con software, IA y estrategias que generan impacto real. Desarrollo de software, automatizaciones y gestión estratégica." />
    
    <meta property="og:title" content="High Impact Studio | Software & IA" />
    <meta property="og:description" content="Creamos soluciones digitales que automatizan, escalan y transforman tu operación." />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="/attached_assets/og-image.png" />
    
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@highimpact" />
    <meta name="twitter:title" content="High Impact Studio" />
    <meta name="twitter:description" content="Impulsa tu negocio con software, IA y estrategias que generan impacto real." />

    <link rel="icon" type="image/png" href="/favicon.png" />
    
    <!-- Fonts: Space Grotesk (Headings) & Inter (Body) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&family=Space+Grotesk:wght@300..700&display=swap" rel="stylesheet">

    <!-- Estilos para el canvas de fondo (átomos IA) -->
    <style>
      /* canvas fijo detrás del contenido, no bloquea eventos */
      #ai-atoms {
        position: fixed;
        inset: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 0;
        display: block;
        mix-blend-mode: screen;
        opacity: 0.9;
      }

      /* mobile adjustments: make particles lighter and less dense */
      @media (max-width: 768px) {
        #ai-atoms {
          opacity: 0.7;
          mix-blend-mode: normal;
        }
      }
      /* Asegurar que el contenido principal quede por encima del canvas */
      #root {
        position: relative;
        z-index: 1;
      }
      /* Ajuste visual: el fondo de página sigue siendo negro para contraste */
      body {
        background: #000;
      }
    </style>
  </head>
  <body class="bg-black text-white antialiased selection:bg-white selection:text-black">
    <!-- Canvas de fondo con partículas atómicas -->
    <canvas id="ai-atoms" aria-hidden="true"></canvas>

    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>

    <!-- Script que crea partículas blancas que "respiran" y siguen el mouse -->
    <script>
      (function(){
        const canvas = document.getElementById('ai-atoms');
        if (!canvas) return;
        const ctx = canvas.getContext('2d', { alpha: true });
        const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        let DPR = Math.max(1, window.devicePixelRatio || 1);
        let isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0);
        function isMobile() { return isTouch || window.innerWidth <= 768; }
        let mobile = isMobile();
        let width = 0, height = 0;
        let particles = [];
        let lastTime = performance.now();
        let mouse = { x: null, y: null, moved: false, vx:0, vy:0, lastMove: 0 };
        let drawConnections = true;

        function resize() {
          DPR = Math.max(1, window.devicePixelRatio || 1);
          // lower DPR on mobile to save battery/CPU
          if (isMobile()) DPR = Math.min(1, DPR);
          mobile = isMobile();
          width = window.innerWidth;
          height = window.innerHeight;
          canvas.style.width = width + 'px';
          canvas.style.height = height + 'px';
          canvas.width = Math.round(width * DPR);
          canvas.height = Math.round(height * DPR);
          ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
          initParticles();
        }

        function initParticles() {
          // Ajustar cantidad según resolución; límite razonable para rendimiento
          const area = width * height;
          let baseCount;
          if (prefersReduced) {
            // minimal, static-ish background
            baseCount = Math.max(6, Math.floor(area / 200000));
            drawConnections = false;
          } else if (mobile) {
            // fewer particles on mobile
            baseCount = Math.max(12, Math.min(60, Math.floor(area / 120000)));
            drawConnections = false; // disable heavy lines on mobile
          } else {
            baseCount = Math.max(40, Math.min(140, Math.floor(area / 60000)));
            drawConnections = true;
          }
          particles = [];
          for (let i=0; i<baseCount; i++) {
            particles.push(makeParticle());
          }
        }

        function makeParticle() {
          return {
            x: Math.random() * width,
            y: Math.random() * height,
            vx: (Math.random() - 0.5) * 0.3,
            vy: (Math.random() - 0.5) * 0.3,
            baseR: 0.7 + Math.random() * 2.2,
            phase: Math.random() * Math.PI * 2,
            breatheSpeed: 0.6 + Math.random() * 1.2,
          };
        }

        function onMove(e) {
          const rect = canvas.getBoundingClientRect();
          const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
          const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
          if (mouse.x != null) {
            mouse.vx = x - mouse.x;
            mouse.vy = y - mouse.y;
          }
          mouse.x = x;
          mouse.y = y;
          mouse.moved = true;
          mouse.lastMove = performance.now();
        }

        function onLeave() {
          mouse.moved = false;
          mouse.x = null;
          mouse.y = null;
        }

        function update(dt, now) {
          const attractionStrength = 0.0025; // cómo atraen las partículas al mouse
          const idleAttract = 0.00015; // atracción suave hacia el centro cuando sin mouse
          for (let p of particles) {
            // breathing phase advance
            p.phase += p.breatheSpeed * dt * 0.001;

            // attraction to mouse or to center if idle
            if (mouse.x != null) {
              const dx = mouse.x - p.x;
              const dy = mouse.y - p.y;
              p.vx += dx * attractionStrength * (0.9 + Math.random()*0.2);
              p.vy += dy * attractionStrength * (0.9 + Math.random()*0.2);
            } else {
              // suave centrado para movimiento orgánico
              const cx = width * 0.5, cy = height * 0.5;
              p.vx += (cx - p.x) * idleAttract;
              p.vy += (cy - p.y) * idleAttract;
            }

            // small noise to keep them alive
            p.vx += (Math.random() - 0.5) * 0.02;
            p.vy += (Math.random() - 0.5) * 0.02;

            // damping
            p.vx *= 0.985;
            p.vy *= 0.985;

            p.x += p.vx;
            p.y += p.vy;

            // wrap edges for continuous field
            if (p.x < -10) p.x = width + 10;
            if (p.x > width + 10) p.x = -10;
            if (p.y < -10) p.y = height + 10;
            if (p.y > height + 10) p.y = -10;
          }
        }

        function draw(now) {
          ctx.clearRect(0, 0, width, height);
          const t = now * 0.002;

          // draw connections (disabled on mobile / reduced motion)
          if (drawConnections) {
            const maxDist = Math.min(140, Math.max(80, Math.hypot(width, height) * 0.06));
            const maxDistSq = maxDist * maxDist;

            // draw particle-to-particle lines
            for (let i=0;i<particles.length;i++) {
              const a = particles[i];
              for (let j=i+1;j<particles.length;j++) {
                const b = particles[j];
                const dx = a.x - b.x, dy = a.y - b.y;
                const d2 = dx*dx + dy*dy;
                if (d2 < maxDistSq) {
                  const alpha = 0.18 * (1 - d2 / maxDistSq);
                  ctx.beginPath();
                  ctx.moveTo(a.x, a.y);
                  ctx.lineTo(b.x, b.y);
                  ctx.strokeStyle = 'rgba(255,255,255,' + (alpha * 0.9) + ')';
                  ctx.lineWidth = 0.6;
                  ctx.stroke();
                }
              }
            }

            // optionally connect to mouse with stronger lines
            if (mouse.x != null) {
              for (let p of particles) {
                const dx = p.x - mouse.x, dy = p.y - mouse.y;
                const d2 = dx*dx + dy*dy;
                const close = Math.min(1, 1 - (d2 / (maxDistSq * 1.5)));
                if (close > 0) {
                  ctx.beginPath();
                  ctx.moveTo(p.x, p.y);
                  ctx.lineTo(mouse.x, mouse.y);
                  ctx.strokeStyle = 'rgba(255,255,255,' + (0.2 * close) + ')';
                  ctx.lineWidth = 0.7;
                  ctx.stroke();
                }
              }
            }
          }

          // draw particles (átomos) as pulsing circles
          for (let p of particles) {
            const breathe = 0.55 + 0.45 * Math.sin(p.phase + t * 2.0);
            const r = p.baseR * (1 + 0.6 * breathe);
            const alpha = 0.5 + 0.5 * breathe; // visible blanco
            ctx.beginPath();
            ctx.fillStyle = 'rgba(255,255,255,' + Math.min(1, alpha) + ')';
            ctx.arc(p.x, p.y, Math.max(0.6, r), 0, Math.PI * 2);
            ctx.fill();
          }
        }

        function loop(now) {
          const dt = Math.min(32, now - lastTime);
          lastTime = now;
          update(dt, now);
          draw(now);
          requestAnimationFrame(loop);
        }

        // Eventos
        window.addEventListener('resize', () => resize());
        window.addEventListener('mousemove', onMove, { passive: true });
        window.addEventListener('touchmove', onMove, { passive: true });
        window.addEventListener('mouseleave', onLeave);
        window.addEventListener('touchend', onLeave);
        window.addEventListener('blur', onLeave);

        // iniciar
        resize();
        lastTime = performance.now();
        requestAnimationFrame(loop);
      })();
    </script>
  </body>
</html>
